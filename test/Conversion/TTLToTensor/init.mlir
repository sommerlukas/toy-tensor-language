// RUN: ttl-opt --convert-ttl-to-tensor %s | FileCheck %s

func.func @matrix_rand_init() -> !ttl.tensor<2x2x!ttl.int> {
  %0 = "ttl.tensor_empty"() : () -> !ttl.tensor<2x2x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<2x2x!ttl.int>) -> ()
}

func.func @matrix_scalar_init() -> !ttl.tensor<3x4x!ttl.float> {
  %0 = "ttl.const_float"() <{constVal = 4.200000e+01 : f32}> : () -> !ttl.float
  %1 = "ttl.tensor_scalar_init"(%0) : (!ttl.float) -> !ttl.tensor<3x4x!ttl.float>
  "ttl.return"(%1) : (!ttl.tensor<3x4x!ttl.float>) -> ()
}

func.func @matrix_range_init() -> !ttl.tensor<4x4x!ttl.int> {
  %0 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %1 = "ttl.const_int"() <{constVal = 17 : i32}> : () -> !ttl.int
  %2 = "ttl.tensor_range_init"(%0, %1) : (!ttl.int, !ttl.int) -> !ttl.tensor<4x4x!ttl.int>
  "ttl.return"(%2) : (!ttl.tensor<4x4x!ttl.int>) -> ()
}

func.func @fixed_matrix_elem_assign(%arg0: !ttl.float) -> !ttl.tensor<2x2x!ttl.float> {
  %0 = "ttl.const_float"() <{constVal = 2.500000e+01 : f32}> : () -> !ttl.float
  %1 = "ttl.tensor_scalar_init"(%0) : (!ttl.float) -> !ttl.tensor<2x2x!ttl.float>
  %2 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
  %3 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %4 = "ttl.tensor_insert"(%1, %arg0, %2, %3) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
  "ttl.return"(%4) : (!ttl.tensor<2x2x!ttl.float>) -> ()
}

func.func @dyn_matrix_elem_assign(%arg0: !ttl.float, %arg1: !ttl.int, %arg2: !ttl.int) -> !ttl.tensor<2x2x!ttl.float> {
  %0 = "ttl.const_float"() <{constVal = 2.500000e+01 : f32}> : () -> !ttl.float
  %1 = "ttl.tensor_scalar_init"(%0) : (!ttl.float) -> !ttl.tensor<2x2x!ttl.float>
  %2 = "ttl.tensor_insert"(%1, %arg0, %arg1, %arg2) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
  "ttl.return"(%2) : (!ttl.tensor<2x2x!ttl.float>) -> ()
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @matrix_rand_init() -> !ttl.tensor<2x2x!ttl.int> {
// CHECK:           %[[VAL_0:.*]] =  tensor.empty() : tensor<2x2xi32>
// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : tensor<2x2xi32> to !ttl.tensor<2x2x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_1]]) : (!ttl.tensor<2x2x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @matrix_scalar_init() -> !ttl.tensor<3x4x!ttl.float> {
// CHECK:           %[[VAL_0:.*]] = "ttl.const_float"() <{constVal = 4.200000e+01 : f32}> : () -> !ttl.float
// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.float to f32
// CHECK:           %[[VAL_2:.*]] = tensor.splat %[[VAL_1]] : tensor<3x4xf32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : tensor<3x4xf32> to !ttl.tensor<3x4x!ttl.float>
// CHECK:           "ttl.return"(%[[VAL_3]]) : (!ttl.tensor<3x4x!ttl.float>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @matrix_range_init() -> !ttl.tensor<4x4x!ttl.int> {
// CHECK:           %[[VAL_0:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.int to i32
// CHECK:           %[[VAL_2:.*]] = "ttl.const_int"() <{constVal = 17 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_3:.*]] = tensor.generate  {
// CHECK:           ^bb0(%[[VAL_4:.*]]: index, %[[VAL_5:.*]]: index):
// CHECK:             %[[VAL_6:.*]] = index.constant 4
// CHECK:             %[[VAL_7:.*]] = index.mul %[[VAL_4]], %[[VAL_6]]
// CHECK:             %[[VAL_8:.*]] = index.add %[[VAL_7]], %[[VAL_5]]
// CHECK:             %[[VAL_9:.*]] = index.casts %[[VAL_8]] : index to i32
// CHECK:             %[[VAL_10:.*]] = arith.addi %[[VAL_1]], %[[VAL_9]] : i32
// CHECK:             tensor.yield %[[VAL_10]] : i32
// CHECK:           } : tensor<4x4xi32>
// CHECK:           %[[VAL_11:.*]] = builtin.unrealized_conversion_cast %[[VAL_12:.*]] : tensor<4x4xi32> to !ttl.tensor<4x4x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_11]]) : (!ttl.tensor<4x4x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @fixed_matrix_elem_assign(
// CHECK-SAME:                                        %[[VAL_0:.*]]: !ttl.float) -> !ttl.tensor<2x2x!ttl.float> {
// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.float to f32
// CHECK:           %[[VAL_2:.*]] = "ttl.const_float"() <{constVal = 2.500000e+01 : f32}> : () -> !ttl.float
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !ttl.float to f32
// CHECK:           %[[VAL_4:.*]] = tensor.splat %[[VAL_3]] : tensor<2x2xf32>
// CHECK:           %[[VAL_5:.*]] = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : !ttl.int to i32
// CHECK:           %[[VAL_7:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_8:.*]] = builtin.unrealized_conversion_cast %[[VAL_7]] : !ttl.int to i32
// CHECK:           %[[VAL_9:.*]] = index.casts %[[VAL_6]] : i32 to index
// CHECK:           %[[VAL_10:.*]] = index.casts %[[VAL_8]] : i32 to index
// CHECK:           %[[VAL_11:.*]] = tensor.insert %[[VAL_1]] into %[[VAL_4]]{{\[}}%[[VAL_9]], %[[VAL_10]]] : tensor<2x2xf32>
// CHECK:           %[[VAL_12:.*]] = builtin.unrealized_conversion_cast %[[VAL_11]] : tensor<2x2xf32> to !ttl.tensor<2x2x!ttl.float>
// CHECK:           "ttl.return"(%[[VAL_12]]) : (!ttl.tensor<2x2x!ttl.float>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @dyn_matrix_elem_assign(
// CHECK-SAME:                                      %[[VAL_0:.*]]: !ttl.float,
// CHECK-SAME:                                      %[[VAL_1:.*]]: !ttl.int,
// CHECK-SAME:                                      %[[VAL_2:.*]]: !ttl.int) -> !ttl.tensor<2x2x!ttl.float> {
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !ttl.int to i32
// CHECK:           %[[VAL_4:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.int to i32
// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.float to f32
// CHECK:           %[[VAL_6:.*]] = "ttl.const_float"() <{constVal = 2.500000e+01 : f32}> : () -> !ttl.float
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : !ttl.float to f32
// CHECK:           %[[VAL_8:.*]] = tensor.splat %[[VAL_7]] : tensor<2x2xf32>
// CHECK:           %[[VAL_9:.*]] = index.casts %[[VAL_4]] : i32 to index
// CHECK:           %[[VAL_10:.*]] = index.casts %[[VAL_3]] : i32 to index
// CHECK:           %[[VAL_11:.*]] = tensor.insert %[[VAL_5]] into %[[VAL_8]]{{\[}}%[[VAL_9]], %[[VAL_10]]] : tensor<2x2xf32>
// CHECK:           %[[VAL_12:.*]] = builtin.unrealized_conversion_cast %[[VAL_11]] : tensor<2x2xf32> to !ttl.tensor<2x2x!ttl.float>
// CHECK:           "ttl.return"(%[[VAL_12]]) : (!ttl.tensor<2x2x!ttl.float>) -> ()
// CHECK:         }

