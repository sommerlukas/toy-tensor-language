// RUN: ttl-opt --convert-ttl-to-tensor %s | FileCheck %s

func.func @dim(%arg0: !ttl.tensor<4x4x!ttl.float>) -> !ttl.int {
  %0 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %1 = "ttl.dim"(%arg0, %0) : (!ttl.tensor<4x4x!ttl.float>, !ttl.int) -> !ttl.int
  "ttl.return"(%1) : (!ttl.int) -> ()
}

func.func @dim_dyn(%arg0: !ttl.tensor<?x?x?x!ttl.int>, %arg1: !ttl.int) -> !ttl.int {
  %0 = "ttl.dim"(%arg0, %arg1) : (!ttl.tensor<?x?x?x!ttl.int>, !ttl.int) -> !ttl.int
  "ttl.return"(%0) : (!ttl.int) -> ()
}

func.func @slice_mixed(%arg0: !ttl.tensor<?x?x!ttl.int>, %arg1: !ttl.int, %arg2: !ttl.int, %arg3: !ttl.int) -> !ttl.tensor<?x1x!ttl.int> {
  %0 = "ttl.sub"(%arg2, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
  %1 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %2 = "ttl.slice"(%arg0, %arg1, %arg3, %0, %1) : (!ttl.tensor<?x?x!ttl.int>, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.tensor<?x1x!ttl.int>
  "ttl.return"(%2) : (!ttl.tensor<?x1x!ttl.int>) -> ()
}

func.func @slice_range(%arg0: !ttl.tensor<16x16x16x!ttl.float>, %arg1: !ttl.int, %arg2: !ttl.int, %arg3: !ttl.int, %arg4: !ttl.int, %arg5: !ttl.int, %arg6: !ttl.int) -> !ttl.tensor<?x?x?x!ttl.float> {
  %0 = "ttl.sub"(%arg2, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
  %1 = "ttl.sub"(%arg4, %arg3) : (!ttl.int, !ttl.int) -> !ttl.int
  %2 = "ttl.sub"(%arg6, %arg5) : (!ttl.int, !ttl.int) -> !ttl.int
  %3 = "ttl.slice"(%arg0, %arg1, %arg3, %arg5, %0, %1, %2) : (!ttl.tensor<16x16x16x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.tensor<?x?x?x!ttl.float>
  "ttl.return"(%3) : (!ttl.tensor<?x?x?x!ttl.float>) -> ()
}

func.func @slice_int(%arg0: !ttl.tensor<?x?x?x!ttl.float>, %arg1: !ttl.int, %arg2: !ttl.int, %arg3: !ttl.int) -> !ttl.float {
  %0 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %1 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %2 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
  %3 = "ttl.slice"(%arg0, %arg1, %arg2, %arg3, %0, %1, %2) : (!ttl.tensor<?x?x?x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.float
  "ttl.return"(%3) : (!ttl.float) -> ()
}

func.func @matrix_init(%arg0: !ttl.float, %arg1: !ttl.float, %arg2: !ttl.float, %arg3: !ttl.float, %arg4: !ttl.float) -> !ttl.tensor<2x2x!ttl.float> {
  %0 = "ttl.add"(%arg3, %arg4) : (!ttl.float, !ttl.float) -> !ttl.float
  %1 = "ttl.tensor_list_init"(%arg0, %arg1, %arg2, %0) : (!ttl.float, !ttl.float, !ttl.float, !ttl.float) -> !ttl.tensor<2x2x!ttl.float>
  "ttl.return"(%1) : (!ttl.tensor<2x2x!ttl.float>) -> ()
}
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @dim(
// CHECK-SAME:                   %[[VAL_0:.*]]: !ttl.tensor<4x4x!ttl.float>) -> !ttl.int {
// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<4x4x!ttl.float> to tensor<4x4xf32>
// CHECK:           %[[VAL_2:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !ttl.int to i32
// CHECK:           %[[VAL_4:.*]] = index.casts %[[VAL_3]] : i32 to index
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_1]], %[[VAL_4]] : tensor<4x4xf32>
// CHECK:           %[[VAL_6:.*]] = index.casts %[[VAL_5]] : index to i32
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : i32 to !ttl.int
// CHECK:           "ttl.return"(%[[VAL_7]]) : (!ttl.int) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @dim_dyn(
// CHECK-SAME:                       %[[VAL_0:.*]]: !ttl.tensor<?x?x?x!ttl.int>,
// CHECK-SAME:                       %[[VAL_1:.*]]: !ttl.int) -> !ttl.int {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.int to i32
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x?x!ttl.int> to tensor<?x?x?xi32>
// CHECK:           %[[VAL_4:.*]] = index.casts %[[VAL_2]] : i32 to index
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_3]], %[[VAL_4]] : tensor<?x?x?xi32>
// CHECK:           %[[VAL_6:.*]] = index.casts %[[VAL_5]] : index to i32
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : i32 to !ttl.int
// CHECK:           "ttl.return"(%[[VAL_7]]) : (!ttl.int) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @slice_mixed(
// CHECK-SAME:                           %[[VAL_0:.*]]: !ttl.tensor<?x?x!ttl.int>,
// CHECK-SAME:                           %[[VAL_1:.*]]: !ttl.int, %[[VAL_2:.*]]: !ttl.int,
// CHECK-SAME:                           %[[VAL_3:.*]]: !ttl.int) -> !ttl.tensor<?x1x!ttl.int> {
// CHECK:           %[[VAL_4:.*]] = builtin.unrealized_conversion_cast %[[VAL_3]] : !ttl.int to i32
// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.int to i32
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_7:.*]] = "ttl.sub"(%[[VAL_2]], %[[VAL_1]]) : (!ttl.int, !ttl.int) -> !ttl.int
// CHECK:           %[[VAL_8:.*]] = builtin.unrealized_conversion_cast %[[VAL_7]] : !ttl.int to i32
// CHECK:           %[[VAL_9:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_10:.*]] = index.casts %[[VAL_5]] : i32 to index
// CHECK:           %[[VAL_11:.*]] = index.casts %[[VAL_8]] : i32 to index
// CHECK:           %[[VAL_12:.*]] = index.casts %[[VAL_4]] : i32 to index
// CHECK:           %[[VAL_13:.*]] = tensor.extract_slice %[[VAL_6]]{{\[}}%[[VAL_10]], %[[VAL_12]]] {{\[}}%[[VAL_11]], 1] [1, 1] : tensor<?x?xi32> to tensor<?x1xi32>
// CHECK:           %[[VAL_14:.*]] = builtin.unrealized_conversion_cast %[[VAL_13]] : tensor<?x1xi32> to !ttl.tensor<?x1x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_14]]) : (!ttl.tensor<?x1x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @slice_range(
// CHECK-SAME:                           %[[VAL_0:.*]]: !ttl.tensor<16x16x16x!ttl.float>,
// CHECK-SAME:                           %[[VAL_1:.*]]: !ttl.int, %[[VAL_2:.*]]: !ttl.int, %[[VAL_3:.*]]: !ttl.int, %[[VAL_4:.*]]: !ttl.int, %[[VAL_5:.*]]: !ttl.int,
// CHECK-SAME:                           %[[VAL_6:.*]]: !ttl.int) -> !ttl.tensor<?x?x?x!ttl.float> {
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : !ttl.int to i32
// CHECK:           %[[VAL_8:.*]] = builtin.unrealized_conversion_cast %[[VAL_3]] : !ttl.int to i32
// CHECK:           %[[VAL_9:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.int to i32
// CHECK:           %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<16x16x16x!ttl.float> to tensor<16x16x16xf32>
// CHECK:           %[[VAL_11:.*]] = "ttl.sub"(%[[VAL_2]], %[[VAL_1]]) : (!ttl.int, !ttl.int) -> !ttl.int
// CHECK:           %[[VAL_12:.*]] = builtin.unrealized_conversion_cast %[[VAL_11]] : !ttl.int to i32
// CHECK:           %[[VAL_13:.*]] = "ttl.sub"(%[[VAL_4]], %[[VAL_3]]) : (!ttl.int, !ttl.int) -> !ttl.int
// CHECK:           %[[VAL_14:.*]] = builtin.unrealized_conversion_cast %[[VAL_13]] : !ttl.int to i32
// CHECK:           %[[VAL_15:.*]] = "ttl.sub"(%[[VAL_6]], %[[VAL_5]]) : (!ttl.int, !ttl.int) -> !ttl.int
// CHECK:           %[[VAL_16:.*]] = builtin.unrealized_conversion_cast %[[VAL_15]] : !ttl.int to i32
// CHECK:           %[[VAL_17:.*]] = index.casts %[[VAL_9]] : i32 to index
// CHECK:           %[[VAL_18:.*]] = index.casts %[[VAL_12]] : i32 to index
// CHECK:           %[[VAL_19:.*]] = index.casts %[[VAL_8]] : i32 to index
// CHECK:           %[[VAL_20:.*]] = index.casts %[[VAL_14]] : i32 to index
// CHECK:           %[[VAL_21:.*]] = index.casts %[[VAL_7]] : i32 to index
// CHECK:           %[[VAL_22:.*]] = index.casts %[[VAL_16]] : i32 to index
// CHECK:           %[[VAL_23:.*]] = tensor.extract_slice %[[VAL_10]]{{\[}}%[[VAL_17]], %[[VAL_19]], %[[VAL_21]]] {{\[}}%[[VAL_18]], %[[VAL_20]], %[[VAL_22]]] [1, 1, 1] : tensor<16x16x16xf32> to tensor<?x?x?xf32>
// CHECK:           %[[VAL_24:.*]] = builtin.unrealized_conversion_cast %[[VAL_23]] : tensor<?x?x?xf32> to !ttl.tensor<?x?x?x!ttl.float>
// CHECK:           "ttl.return"(%[[VAL_24]]) : (!ttl.tensor<?x?x?x!ttl.float>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @slice_int(
// CHECK-SAME:                         %[[VAL_0:.*]]: !ttl.tensor<?x?x?x!ttl.float>,
// CHECK-SAME:                         %[[VAL_1:.*]]: !ttl.int, %[[VAL_2:.*]]: !ttl.int,
// CHECK-SAME:                         %[[VAL_3:.*]]: !ttl.int) -> !ttl.float {
// CHECK:           %[[VAL_4:.*]] = builtin.unrealized_conversion_cast %[[VAL_3]] : !ttl.int to i32
// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !ttl.int to i32
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.int to i32
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x?x!ttl.float> to tensor<?x?x?xf32>
// CHECK:           %[[VAL_8:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_9:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_10:.*]] = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
// CHECK:           %[[VAL_11:.*]] = index.casts %[[VAL_6]] : i32 to index
// CHECK:           %[[VAL_12:.*]] = index.casts %[[VAL_5]] : i32 to index
// CHECK:           %[[VAL_13:.*]] = index.casts %[[VAL_4]] : i32 to index
// CHECK:           %[[VAL_14:.*]] = tensor.extract %[[VAL_7]]{{\[}}%[[VAL_11]], %[[VAL_12]], %[[VAL_13]]] : tensor<?x?x?xf32>
// CHECK:           %[[VAL_15:.*]] = builtin.unrealized_conversion_cast %[[VAL_14]] : f32 to !ttl.float
// CHECK:           "ttl.return"(%[[VAL_15]]) : (!ttl.float) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @matrix_init(
// CHECK-SAME:                           %[[VAL_0:.*]]: !ttl.float, %[[VAL_1:.*]]: !ttl.float, %[[VAL_2:.*]]: !ttl.float, %[[VAL_3:.*]]: !ttl.float,
// CHECK-SAME:                           %[[VAL_4:.*]]: !ttl.float) -> !ttl.tensor<2x2x!ttl.float> {
// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !ttl.float to f32
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.float to f32
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.float to f32
// CHECK:           %[[VAL_8:.*]] = "ttl.add"(%[[VAL_3]], %[[VAL_4]]) : (!ttl.float, !ttl.float) -> !ttl.float
// CHECK:           %[[VAL_9:.*]] = builtin.unrealized_conversion_cast %[[VAL_8]] : !ttl.float to f32
// CHECK:           %[[VAL_10:.*]] = tensor.from_elements %[[VAL_7]], %[[VAL_6]], %[[VAL_5]], %[[VAL_9]] : tensor<2x2xf32>
// CHECK:           %[[VAL_11:.*]] = builtin.unrealized_conversion_cast %[[VAL_10]] : tensor<2x2xf32> to !ttl.tensor<2x2x!ttl.float>
// CHECK:           "ttl.return"(%[[VAL_11]]) : (!ttl.tensor<2x2x!ttl.float>) -> ()
// CHECK:         }

