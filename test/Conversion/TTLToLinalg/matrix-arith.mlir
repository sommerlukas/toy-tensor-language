// RUN: ttl-opt --convert-ttl-to-linalg %s | FileCheck %s

func.func @add(%arg0: !ttl.tensor<4x4x!ttl.int>, %arg1: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
  %0 = "ttl.add"(%arg0, %arg1) : (!ttl.tensor<4x4x!ttl.int>, !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<4x4x!ttl.int>) -> ()
}

func.func @sub(%arg0: !ttl.tensor<4x4x!ttl.int>, %arg1: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
  %0 = "ttl.sub"(%arg0, %arg1) : (!ttl.tensor<4x4x!ttl.int>, !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<4x4x!ttl.int>) -> ()
}

func.func @mul(%arg0: !ttl.tensor<4x4x!ttl.int>, %arg1: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
  %0 = "ttl.mul"(%arg0, %arg1) : (!ttl.tensor<4x4x!ttl.int>, !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<4x4x!ttl.int>) -> ()
}

func.func @div(%arg0: !ttl.tensor<4x4x!ttl.int>, %arg1: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
  %0 = "ttl.div"(%arg0, %arg1) : (!ttl.tensor<4x4x!ttl.int>, !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<4x4x!ttl.int>) -> ()
}

func.func @add_dyn(%arg0: !ttl.tensor<?x?x!ttl.int>, %arg1: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
  %0 = "ttl.add"(%arg0, %arg1) : (!ttl.tensor<?x?x!ttl.int>, !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<?x?x!ttl.int>) -> ()
}

func.func @sub_dyn(%arg0: !ttl.tensor<?x?x!ttl.int>, %arg1: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
  %0 = "ttl.sub"(%arg0, %arg1) : (!ttl.tensor<?x?x!ttl.int>, !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<?x?x!ttl.int>) -> ()
}

func.func @mul_dyn(%arg0: !ttl.tensor<?x?x!ttl.int>, %arg1: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
  %0 = "ttl.mul"(%arg0, %arg1) : (!ttl.tensor<?x?x!ttl.int>, !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<?x?x!ttl.int>) -> ()
}

func.func @div_dyn(%arg0: !ttl.tensor<?x?x!ttl.int>, %arg1: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
  %0 = "ttl.div"(%arg0, %arg1) : (!ttl.tensor<?x?x!ttl.int>, !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int>
  "ttl.return"(%0) : (!ttl.tensor<?x?x!ttl.int>) -> ()
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @add(
// CHECK-SAME:                   %[[VAL_0:.*]]: !ttl.tensor<4x4x!ttl.int>,
// CHECK-SAME:                   %[[VAL_1:.*]]: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_4:.*]] = tensor.empty() : tensor<4x4xi32>
// CHECK:           %[[VAL_5:.*]] = linalg.add ins(%[[VAL_3]], %[[VAL_2]] : tensor<4x4xi32>, tensor<4x4xi32>) outs(%[[VAL_4]] : tensor<4x4xi32>) -> tensor<4x4xi32>
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : tensor<4x4xi32> to !ttl.tensor<4x4x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_6]]) : (!ttl.tensor<4x4x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @sub(
// CHECK-SAME:                   %[[VAL_0:.*]]: !ttl.tensor<4x4x!ttl.int>,
// CHECK-SAME:                   %[[VAL_1:.*]]: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_4:.*]] = tensor.empty() : tensor<4x4xi32>
// CHECK:           %[[VAL_5:.*]] = linalg.sub ins(%[[VAL_3]], %[[VAL_2]] : tensor<4x4xi32>, tensor<4x4xi32>) outs(%[[VAL_4]] : tensor<4x4xi32>) -> tensor<4x4xi32>
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : tensor<4x4xi32> to !ttl.tensor<4x4x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_6]]) : (!ttl.tensor<4x4x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @mul(
// CHECK-SAME:                   %[[VAL_0:.*]]: !ttl.tensor<4x4x!ttl.int>,
// CHECK-SAME:                   %[[VAL_1:.*]]: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_4:.*]] = tensor.empty() : tensor<4x4xi32>
// CHECK:           %[[VAL_5:.*]] = linalg.mul ins(%[[VAL_3]], %[[VAL_2]] : tensor<4x4xi32>, tensor<4x4xi32>) outs(%[[VAL_4]] : tensor<4x4xi32>) -> tensor<4x4xi32>
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : tensor<4x4xi32> to !ttl.tensor<4x4x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_6]]) : (!ttl.tensor<4x4x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @div(
// CHECK-SAME:                   %[[VAL_0:.*]]: !ttl.tensor<4x4x!ttl.int>,
// CHECK-SAME:                   %[[VAL_1:.*]]: !ttl.tensor<4x4x!ttl.int>) -> !ttl.tensor<4x4x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<4x4x!ttl.int> to tensor<4x4xi32>
// CHECK:           %[[VAL_4:.*]] = tensor.empty() : tensor<4x4xi32>
// CHECK:           %[[VAL_5:.*]] = linalg.div ins(%[[VAL_3]], %[[VAL_2]] : tensor<4x4xi32>, tensor<4x4xi32>) outs(%[[VAL_4]] : tensor<4x4xi32>) -> tensor<4x4xi32>
// CHECK:           %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_5]] : tensor<4x4xi32> to !ttl.tensor<4x4x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_6]]) : (!ttl.tensor<4x4x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @add_dyn(
// CHECK-SAME:                       %[[VAL_0:.*]]: !ttl.tensor<?x?x!ttl.int>,
// CHECK-SAME:                       %[[VAL_1:.*]]: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_4:.*]] = index.constant 0
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_3]], %[[VAL_4]] : tensor<?x?xi32>
// CHECK:           %[[VAL_6:.*]] = index.constant 1
// CHECK:           %[[VAL_7:.*]] = tensor.dim %[[VAL_3]], %[[VAL_6]] : tensor<?x?xi32>
// CHECK:           %[[VAL_8:.*]] = tensor.empty(%[[VAL_5]], %[[VAL_7]]) : tensor<?x?xi32>
// CHECK:           %[[VAL_9:.*]] = linalg.add ins(%[[VAL_3]], %[[VAL_2]] : tensor<?x?xi32>, tensor<?x?xi32>) outs(%[[VAL_8]] : tensor<?x?xi32>) -> tensor<?x?xi32>
// CHECK:           %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_9]] : tensor<?x?xi32> to !ttl.tensor<?x?x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_10]]) : (!ttl.tensor<?x?x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @sub_dyn(
// CHECK-SAME:                       %[[VAL_0:.*]]: !ttl.tensor<?x?x!ttl.int>,
// CHECK-SAME:                       %[[VAL_1:.*]]: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_4:.*]] = index.constant 0
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_3]], %[[VAL_4]] : tensor<?x?xi32>
// CHECK:           %[[VAL_6:.*]] = index.constant 1
// CHECK:           %[[VAL_7:.*]] = tensor.dim %[[VAL_3]], %[[VAL_6]] : tensor<?x?xi32>
// CHECK:           %[[VAL_8:.*]] = tensor.empty(%[[VAL_5]], %[[VAL_7]]) : tensor<?x?xi32>
// CHECK:           %[[VAL_9:.*]] = linalg.sub ins(%[[VAL_3]], %[[VAL_2]] : tensor<?x?xi32>, tensor<?x?xi32>) outs(%[[VAL_8]] : tensor<?x?xi32>) -> tensor<?x?xi32>
// CHECK:           %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_9]] : tensor<?x?xi32> to !ttl.tensor<?x?x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_10]]) : (!ttl.tensor<?x?x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @mul_dyn(
// CHECK-SAME:                       %[[VAL_0:.*]]: !ttl.tensor<?x?x!ttl.int>,
// CHECK-SAME:                       %[[VAL_1:.*]]: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_4:.*]] = index.constant 0
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_3]], %[[VAL_4]] : tensor<?x?xi32>
// CHECK:           %[[VAL_6:.*]] = index.constant 1
// CHECK:           %[[VAL_7:.*]] = tensor.dim %[[VAL_3]], %[[VAL_6]] : tensor<?x?xi32>
// CHECK:           %[[VAL_8:.*]] = tensor.empty(%[[VAL_5]], %[[VAL_7]]) : tensor<?x?xi32>
// CHECK:           %[[VAL_9:.*]] = linalg.mul ins(%[[VAL_3]], %[[VAL_2]] : tensor<?x?xi32>, tensor<?x?xi32>) outs(%[[VAL_8]] : tensor<?x?xi32>) -> tensor<?x?xi32>
// CHECK:           %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_9]] : tensor<?x?xi32> to !ttl.tensor<?x?x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_10]]) : (!ttl.tensor<?x?x!ttl.int>) -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @div_dyn(
// CHECK-SAME:                       %[[VAL_0:.*]]: !ttl.tensor<?x?x!ttl.int>,
// CHECK-SAME:                       %[[VAL_1:.*]]: !ttl.tensor<?x?x!ttl.int>) -> !ttl.tensor<?x?x!ttl.int> {
// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_1]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !ttl.tensor<?x?x!ttl.int> to tensor<?x?xi32>
// CHECK:           %[[VAL_4:.*]] = index.constant 0
// CHECK:           %[[VAL_5:.*]] = tensor.dim %[[VAL_3]], %[[VAL_4]] : tensor<?x?xi32>
// CHECK:           %[[VAL_6:.*]] = index.constant 1
// CHECK:           %[[VAL_7:.*]] = tensor.dim %[[VAL_3]], %[[VAL_6]] : tensor<?x?xi32>
// CHECK:           %[[VAL_8:.*]] = tensor.empty(%[[VAL_5]], %[[VAL_7]]) : tensor<?x?xi32>
// CHECK:           %[[VAL_9:.*]] = linalg.div ins(%[[VAL_3]], %[[VAL_2]] : tensor<?x?xi32>, tensor<?x?xi32>) outs(%[[VAL_8]] : tensor<?x?xi32>) -> tensor<?x?xi32>
// CHECK:           %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_9]] : tensor<?x?xi32> to !ttl.tensor<?x?x!ttl.int>
// CHECK:           "ttl.return"(%[[VAL_10]]) : (!ttl.tensor<?x?x!ttl.int>) -> ()
// CHECK:         }

