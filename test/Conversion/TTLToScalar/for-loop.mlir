// RUN: ttl-opt --convert-ttl-to-scalar %s | FileCheck %s

module {
  func.func @control_flow_if(%arg0: !ttl.int, %arg1: !ttl.int, %arg2: !ttl.int, %arg3: !ttl.int) -> !ttl.float {
    %0 = "ttl.tensor_empty"() : () -> !ttl.tensor<8x8x!ttl.float>
    %1 = "ttl.tensor_empty"() : () -> !ttl.tensor<8x!ttl.float>
    %2 = "ttl.const_float"() <{constVal = 5.000000e+00 : f32}> : () -> !ttl.float
    %3 = "ttl.const_float"() <{constVal = 6.000000e+00 : f32}> : () -> !ttl.float
    %4 = "ttl.const_float"() <{constVal = 8.000000e+00 : f32}> : () -> !ttl.float
    %5 = "ttl.const_float"() <{constVal = 1.000000e+00 : f32}> : () -> !ttl.float
    %6 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
    %7 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
    %8 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %9:5 = "ttl.for"(%arg1, %arg2, %8, %2, %3, %4, %0, %1) ({
    ^bb0(%arg4: !ttl.int, %arg5: !ttl.float, %arg6: !ttl.float, %arg7: !ttl.float, %arg8: !ttl.tensor<8x8x!ttl.float>, %arg9: !ttl.tensor<8x!ttl.float>):
      %23 = "ttl.const_float"() <{constVal = 8.000000e+00 : f32}> : () -> !ttl.float
      %24 = "ttl.const_float"() <{constVal = 7.000000e+00 : f32}> : () -> !ttl.float
      %25 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
      %26 = "ttl.const_int"() <{constVal = 2 : i32}> : () -> !ttl.int
      %27:2 = "ttl.for"(%25, %arg3, %26, %arg7, %arg8) ({
      ^bb0(%arg10: !ttl.int, %arg11: !ttl.float, %arg12: !ttl.tensor<8x8x!ttl.float>):
        %29 = "ttl.if"(%arg0) ({
          %31 = "ttl.const_float"() <{constVal = 4.200000e+01 : f32}> : () -> !ttl.float
          "ttl.yield"(%31) : (!ttl.float) -> ()
        }, {
          "ttl.yield"(%arg11) : (!ttl.float) -> ()
        }) : (!ttl.int) -> !ttl.float
        %30 = "ttl.tensor_insert"(%arg12, %23, %arg4, %arg10) : (!ttl.tensor<8x8x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<8x8x!ttl.float>
        "ttl.yield"(%29, %30) : (!ttl.float, !ttl.tensor<8x8x!ttl.float>) -> ()
      }) : (!ttl.int, !ttl.int, !ttl.int, !ttl.float, !ttl.tensor<8x8x!ttl.float>) -> (!ttl.float, !ttl.tensor<8x8x!ttl.float>)
      %28 = "ttl.tensor_insert"(%arg9, %24, %arg4) : (!ttl.tensor<8x!ttl.float>, !ttl.float, !ttl.int) -> !ttl.tensor<8x!ttl.float>
      "ttl.yield"(%23, %24, %27#0, %27#1, %28) : (!ttl.float, !ttl.float, !ttl.float, !ttl.tensor<8x8x!ttl.float>, !ttl.tensor<8x!ttl.float>) -> ()
    }) : (!ttl.int, !ttl.int, !ttl.int, !ttl.float, !ttl.float, !ttl.float, !ttl.tensor<8x8x!ttl.float>, !ttl.tensor<8x!ttl.float>) -> (!ttl.float, !ttl.float, !ttl.float, !ttl.tensor<8x8x!ttl.float>, !ttl.tensor<8x!ttl.float>)
    %10 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
    %11 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %12 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %13 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %14 = "ttl.slice"(%9#3, %10, %12, %11, %13) : (!ttl.tensor<8x8x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.float
    %15 = "ttl.const_int"() <{constVal = 2 : i32}> : () -> !ttl.int
    %16 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %17 = "ttl.slice"(%9#4, %15, %16) : (!ttl.tensor<8x!ttl.float>, !ttl.int, !ttl.int) -> !ttl.float
    %18 = "ttl.mul"(%14, %17) : (!ttl.float, !ttl.float) -> !ttl.float
    %19 = "ttl.mul"(%18, %9#0) : (!ttl.float, !ttl.float) -> !ttl.float
    %20 = "ttl.mul"(%19, %9#1) : (!ttl.float, !ttl.float) -> !ttl.float
    %21 = "ttl.mul"(%20, %9#2) : (!ttl.float, !ttl.float) -> !ttl.float
    %22 = "ttl.mul"(%21, %5) : (!ttl.float, !ttl.float) -> !ttl.float
    "ttl.return"(%22) : (!ttl.float) -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @control_flow_if(
// CHECK-SAME:                               %[[VAL_0:.*]]: i32, %[[VAL_1:.*]]: i32, %[[VAL_2:.*]]: i32,
// CHECK-SAME:                               %[[VAL_3:.*]]: i32) -> f32 {
// CHECK:           %[[VAL_4:.*]] = "ttl.tensor_empty"() : () -> !ttl.tensor<8x8x!ttl.float>
// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_4]] : !ttl.tensor<8x8x!ttl.float> to tensor<8x8xf32>
// CHECK:           %[[VAL_6:.*]] = "ttl.tensor_empty"() : () -> !ttl.tensor<8x!ttl.float>
// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : !ttl.tensor<8x!ttl.float> to tensor<8xf32>
// CHECK:           %[[VAL_8:.*]] = arith.constant 5.000000e+00 : f32
// CHECK:           %[[VAL_9:.*]] = arith.constant 6.000000e+00 : f32
// CHECK:           %[[VAL_10:.*]] = arith.constant 8.000000e+00 : f32
// CHECK:           %[[VAL_11:.*]] = arith.constant 1.000000e+00 : f32
// CHECK:           %[[VAL_12:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_13:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_14:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_15:.*]]:5 = scf.for %[[VAL_16:.*]] = %[[VAL_1]] to %[[VAL_2]] step %[[VAL_14]] iter_args(%[[VAL_17:.*]] = %[[VAL_8]], %[[VAL_18:.*]] = %[[VAL_9]], %[[VAL_19:.*]] = %[[VAL_10]], %[[VAL_20:.*]] = %[[VAL_5]], %[[VAL_21:.*]] = %[[VAL_7]]) -> (f32, f32, f32, tensor<8x8xf32>, tensor<8xf32>)  : i32 {
// CHECK:             %[[VAL_22:.*]] = builtin.unrealized_conversion_cast %[[VAL_21]] : tensor<8xf32> to !ttl.tensor<8x!ttl.float>
// CHECK:             %[[VAL_23:.*]] = builtin.unrealized_conversion_cast %[[VAL_16]] : i32 to !ttl.int
// CHECK:             %[[VAL_24:.*]] = arith.constant 8.000000e+00 : f32
// CHECK:             %[[VAL_25:.*]] = builtin.unrealized_conversion_cast %[[VAL_24]] : f32 to !ttl.float
// CHECK:             %[[VAL_26:.*]] = arith.constant 7.000000e+00 : f32
// CHECK:             %[[VAL_27:.*]] = builtin.unrealized_conversion_cast %[[VAL_26]] : f32 to !ttl.float
// CHECK:             %[[VAL_28:.*]] = arith.constant 0 : i32
// CHECK:             %[[VAL_29:.*]] = arith.constant 2 : i32
// CHECK:             %[[VAL_30:.*]]:2 = scf.for %[[VAL_31:.*]] = %[[VAL_28]] to %[[VAL_3]] step %[[VAL_29]] iter_args(%[[VAL_32:.*]] = %[[VAL_19]], %[[VAL_33:.*]] = %[[VAL_20]]) -> (f32, tensor<8x8xf32>)  : i32 {
// CHECK:               %[[VAL_34:.*]] = builtin.unrealized_conversion_cast %[[VAL_33]] : tensor<8x8xf32> to !ttl.tensor<8x8x!ttl.float>
// CHECK:               %[[VAL_35:.*]] = builtin.unrealized_conversion_cast %[[VAL_31]] : i32 to !ttl.int
// CHECK:               %[[VAL_36:.*]] = arith.constant 0 : i32
// CHECK:               %[[VAL_37:.*]] = arith.cmpi ne, %[[VAL_0]], %[[VAL_36]] : i32
// CHECK:               %[[VAL_38:.*]] = scf.if %[[VAL_37]] -> (f32) {
// CHECK:                 %[[VAL_39:.*]] = arith.constant 4.200000e+01 : f32
// CHECK:                 scf.yield %[[VAL_39]] : f32
// CHECK:               } else {
// CHECK:                 scf.yield %[[VAL_32]] : f32
// CHECK:               }
// CHECK:               %[[VAL_40:.*]] = "ttl.tensor_insert"(%[[VAL_34]], %[[VAL_25]], %[[VAL_23]], %[[VAL_35]]) : (!ttl.tensor<8x8x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<8x8x!ttl.float>
// CHECK:               %[[VAL_41:.*]] = builtin.unrealized_conversion_cast %[[VAL_40]] : !ttl.tensor<8x8x!ttl.float> to tensor<8x8xf32>
// CHECK:               scf.yield %[[VAL_38]], %[[VAL_41]] : f32, tensor<8x8xf32>
// CHECK:             }
// CHECK:             %[[VAL_42:.*]] = "ttl.tensor_insert"(%[[VAL_22]], %[[VAL_27]], %[[VAL_23]]) : (!ttl.tensor<8x!ttl.float>, !ttl.float, !ttl.int) -> !ttl.tensor<8x!ttl.float>
// CHECK:             %[[VAL_43:.*]] = builtin.unrealized_conversion_cast %[[VAL_42]] : !ttl.tensor<8x!ttl.float> to tensor<8xf32>
// CHECK:             scf.yield %[[VAL_24]], %[[VAL_26]], %[[VAL_44:.*]]#0, %[[VAL_44]]#1, %[[VAL_43]] : f32, f32, f32, tensor<8x8xf32>, tensor<8xf32>
// CHECK:           }
// CHECK:           %[[VAL_45:.*]] = builtin.unrealized_conversion_cast %[[VAL_46:.*]]#4 : tensor<8xf32> to !ttl.tensor<8x!ttl.float>
// CHECK:           %[[VAL_47:.*]] = builtin.unrealized_conversion_cast %[[VAL_46]]#3 : tensor<8x8xf32> to !ttl.tensor<8x8x!ttl.float>
// CHECK:           %[[VAL_48:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_49:.*]] = builtin.unrealized_conversion_cast %[[VAL_48]] : i32 to !ttl.int
// CHECK:           %[[VAL_50:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_51:.*]] = builtin.unrealized_conversion_cast %[[VAL_50]] : i32 to !ttl.int
// CHECK:           %[[VAL_52:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_53:.*]] = builtin.unrealized_conversion_cast %[[VAL_52]] : i32 to !ttl.int
// CHECK:           %[[VAL_54:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_55:.*]] = builtin.unrealized_conversion_cast %[[VAL_54]] : i32 to !ttl.int
// CHECK:           %[[VAL_56:.*]] = "ttl.slice"(%[[VAL_47]], %[[VAL_49]], %[[VAL_53]], %[[VAL_51]], %[[VAL_55]]) : (!ttl.tensor<8x8x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.float
// CHECK:           %[[VAL_57:.*]] = builtin.unrealized_conversion_cast %[[VAL_56]] : !ttl.float to f32
// CHECK:           %[[VAL_58:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_59:.*]] = builtin.unrealized_conversion_cast %[[VAL_58]] : i32 to !ttl.int
// CHECK:           %[[VAL_60:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_61:.*]] = builtin.unrealized_conversion_cast %[[VAL_60]] : i32 to !ttl.int
// CHECK:           %[[VAL_62:.*]] = "ttl.slice"(%[[VAL_45]], %[[VAL_59]], %[[VAL_61]]) : (!ttl.tensor<8x!ttl.float>, !ttl.int, !ttl.int) -> !ttl.float
// CHECK:           %[[VAL_63:.*]] = builtin.unrealized_conversion_cast %[[VAL_62]] : !ttl.float to f32
// CHECK:           %[[VAL_64:.*]] = arith.mulf %[[VAL_57]], %[[VAL_63]] : f32
// CHECK:           %[[VAL_65:.*]] = arith.mulf %[[VAL_64]], %[[VAL_46]]#0 : f32
// CHECK:           %[[VAL_66:.*]] = arith.mulf %[[VAL_65]], %[[VAL_46]]#1 : f32
// CHECK:           %[[VAL_67:.*]] = arith.mulf %[[VAL_66]], %[[VAL_46]]#2 : f32
// CHECK:           %[[VAL_68:.*]] = arith.mulf %[[VAL_67]], %[[VAL_11]] : f32
// CHECK:           return %[[VAL_68]] : f32
// CHECK:         }

