// RUN: ttl-opt --convert-ttl-to-scalar %s | FileCheck %s

module {
  func.func @control_flow_if(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.float {
    %0 = "ttl.const_float"() <{constVal = 0.000000e+00 : f32}> : () -> !ttl.float
    %1 = "ttl.tensor_empty"() : () -> !ttl.tensor<2x2x!ttl.float>
    %2 = "ttl.const_int"() <{constVal = 42 : i32}> : () -> !ttl.int
    %3 = "ttl.const_int"() <{constVal = 5 : i32}> : () -> !ttl.int
    %4 = "ttl.const_int"() <{constVal = 4 : i32}> : () -> !ttl.int
    %5:5 = "ttl.if"(%arg0) ({
      %12 = "ttl.const_float"() <{constVal = 3.000000e+00 : f32}> : () -> !ttl.float
      %13 = "ttl.const_int"() <{constVal = 25 : i32}> : () -> !ttl.int
      %14:3 = "ttl.if"(%arg1) ({
        %16 = "ttl.const_int"() <{constVal = 42 : i32}> : () -> !ttl.int
        %17 = "ttl.const_float"() <{constVal = 5.000000e+00 : f32}> : () -> !ttl.float
        %18 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
        %19 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
        %20 = "ttl.const_float"() <{constVal = 6.000000e+00 : f32}> : () -> !ttl.float
        %21 = "ttl.tensor_insert"(%1, %20, %18, %19) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
        %22 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
        %23 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
        %24 = "ttl.const_float"() <{constVal = 7.000000e+00 : f32}> : () -> !ttl.float
        %25 = "ttl.tensor_insert"(%21, %24, %22, %23) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
        "ttl.yield"(%16, %17, %25) : (!ttl.int, !ttl.float, !ttl.tensor<2x2x!ttl.float>) -> ()
      }, {
        %16 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
        %17 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
        %18 = "ttl.const_float"() <{constVal = 7.000000e+00 : f32}> : () -> !ttl.float
        %19 = "ttl.tensor_insert"(%1, %18, %16, %17) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
        %20 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
        %21 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
        %22 = "ttl.const_float"() <{constVal = 1.000000e+01 : f32}> : () -> !ttl.float
        %23 = "ttl.tensor_insert"(%19, %22, %20, %21) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
        "ttl.yield"(%4, %12, %23) : (!ttl.int, !ttl.float, !ttl.tensor<2x2x!ttl.float>) -> ()
      }) : (!ttl.int) -> (!ttl.int, !ttl.float, !ttl.tensor<2x2x!ttl.float>)
      %15 = "ttl.const_float"() <{constVal = 9.000000e+00 : f32}> : () -> !ttl.float
      "ttl.yield"(%15, %13, %14#0, %14#2, %3) : (!ttl.float, !ttl.int, !ttl.int, !ttl.tensor<2x2x!ttl.float>, !ttl.int) -> ()
    }, {
      %12 = "ttl.const_float"() <{constVal = 8.000000e+00 : f32}> : () -> !ttl.float
      %13 = "ttl.const_int"() <{constVal = 8 : i32}> : () -> !ttl.int
      "ttl.yield"(%12, %2, %4, %1, %13) : (!ttl.float, !ttl.int, !ttl.int, !ttl.tensor<2x2x!ttl.float>, !ttl.int) -> ()
    }) : (!ttl.int) -> (!ttl.float, !ttl.int, !ttl.int, !ttl.tensor<2x2x!ttl.float>, !ttl.int)
    %6 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %7 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %8 = "ttl.const_int"() <{constVal = 0 : i32}> : () -> !ttl.int
    %9 = "ttl.const_int"() <{constVal = 1 : i32}> : () -> !ttl.int
    %10 = "ttl.slice"(%5#3, %6, %8, %7, %9) : (!ttl.tensor<2x2x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.float
    %11 = "ttl.add"(%5#0, %10) : (!ttl.float, !ttl.float) -> !ttl.float
    "ttl.return"(%11) : (!ttl.float) -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @control_flow_if(
// CHECK-SAME:                               %[[VAL_0:.*]]: i32,
// CHECK-SAME:                               %[[VAL_1:.*]]: i32) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_3:.*]] = "ttl.tensor_empty"() : () -> !ttl.tensor<2x2x!ttl.float>
// CHECK:           %[[VAL_4:.*]] = builtin.unrealized_conversion_cast %[[VAL_3]] : !ttl.tensor<2x2x!ttl.float> to tensor<2x2xf32>
// CHECK:           %[[VAL_5:.*]] = arith.constant 42 : i32
// CHECK:           %[[VAL_6:.*]] = arith.constant 5 : i32
// CHECK:           %[[VAL_7:.*]] = arith.constant 4 : i32
// CHECK:           %[[VAL_8:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_9:.*]] = arith.cmpi ne, %[[VAL_0]], %[[VAL_8]] : i32
// CHECK:           %[[VAL_10:.*]]:5 = scf.if %[[VAL_9]] -> (f32, i32, i32, tensor<2x2xf32>, i32) {
// CHECK:             %[[VAL_11:.*]] = arith.constant 3.000000e+00 : f32
// CHECK:             %[[VAL_12:.*]] = arith.constant 25 : i32
// CHECK:             %[[VAL_13:.*]] = arith.constant 0 : i32
// CHECK:             %[[VAL_14:.*]] = arith.cmpi ne, %[[VAL_1]], %[[VAL_13]] : i32
// CHECK:             %[[VAL_15:.*]]:3 = scf.if %[[VAL_14]] -> (i32, f32, tensor<2x2xf32>) {
// CHECK:               %[[VAL_16:.*]] = arith.constant 42 : i32
// CHECK:               %[[VAL_17:.*]] = arith.constant 5.000000e+00 : f32
// CHECK:               %[[VAL_18:.*]] = arith.constant 0 : i32
// CHECK:               %[[VAL_19:.*]] = builtin.unrealized_conversion_cast %[[VAL_18]] : i32 to !ttl.int
// CHECK:               %[[VAL_20:.*]] = arith.constant 1 : i32
// CHECK:               %[[VAL_21:.*]] = builtin.unrealized_conversion_cast %[[VAL_20]] : i32 to !ttl.int
// CHECK:               %[[VAL_22:.*]] = arith.constant 6.000000e+00 : f32
// CHECK:               %[[VAL_23:.*]] = builtin.unrealized_conversion_cast %[[VAL_22]] : f32 to !ttl.float
// CHECK:               %[[VAL_24:.*]] = "ttl.tensor_insert"(%[[VAL_3]], %[[VAL_23]], %[[VAL_19]], %[[VAL_21]]) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
// CHECK:               %[[VAL_25:.*]] = arith.constant 1 : i32
// CHECK:               %[[VAL_26:.*]] = builtin.unrealized_conversion_cast %[[VAL_25]] : i32 to !ttl.int
// CHECK:               %[[VAL_27:.*]] = arith.constant 0 : i32
// CHECK:               %[[VAL_28:.*]] = builtin.unrealized_conversion_cast %[[VAL_27]] : i32 to !ttl.int
// CHECK:               %[[VAL_29:.*]] = arith.constant 7.000000e+00 : f32
// CHECK:               %[[VAL_30:.*]] = builtin.unrealized_conversion_cast %[[VAL_29]] : f32 to !ttl.float
// CHECK:               %[[VAL_31:.*]] = "ttl.tensor_insert"(%[[VAL_24]], %[[VAL_30]], %[[VAL_26]], %[[VAL_28]]) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
// CHECK:               %[[VAL_32:.*]] = builtin.unrealized_conversion_cast %[[VAL_31]] : !ttl.tensor<2x2x!ttl.float> to tensor<2x2xf32>
// CHECK:               scf.yield %[[VAL_16]], %[[VAL_17]], %[[VAL_32]] : i32, f32, tensor<2x2xf32>
// CHECK:             } else {
// CHECK:               %[[VAL_33:.*]] = arith.constant 0 : i32
// CHECK:               %[[VAL_34:.*]] = builtin.unrealized_conversion_cast %[[VAL_33]] : i32 to !ttl.int
// CHECK:               %[[VAL_35:.*]] = arith.constant 1 : i32
// CHECK:               %[[VAL_36:.*]] = builtin.unrealized_conversion_cast %[[VAL_35]] : i32 to !ttl.int
// CHECK:               %[[VAL_37:.*]] = arith.constant 7.000000e+00 : f32
// CHECK:               %[[VAL_38:.*]] = builtin.unrealized_conversion_cast %[[VAL_37]] : f32 to !ttl.float
// CHECK:               %[[VAL_39:.*]] = "ttl.tensor_insert"(%[[VAL_3]], %[[VAL_38]], %[[VAL_34]], %[[VAL_36]]) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
// CHECK:               %[[VAL_40:.*]] = arith.constant 1 : i32
// CHECK:               %[[VAL_41:.*]] = builtin.unrealized_conversion_cast %[[VAL_40]] : i32 to !ttl.int
// CHECK:               %[[VAL_42:.*]] = arith.constant 1 : i32
// CHECK:               %[[VAL_43:.*]] = builtin.unrealized_conversion_cast %[[VAL_42]] : i32 to !ttl.int
// CHECK:               %[[VAL_44:.*]] = arith.constant 1.000000e+01 : f32
// CHECK:               %[[VAL_45:.*]] = builtin.unrealized_conversion_cast %[[VAL_44]] : f32 to !ttl.float
// CHECK:               %[[VAL_46:.*]] = "ttl.tensor_insert"(%[[VAL_39]], %[[VAL_45]], %[[VAL_41]], %[[VAL_43]]) : (!ttl.tensor<2x2x!ttl.float>, !ttl.float, !ttl.int, !ttl.int) -> !ttl.tensor<2x2x!ttl.float>
// CHECK:               %[[VAL_47:.*]] = builtin.unrealized_conversion_cast %[[VAL_46]] : !ttl.tensor<2x2x!ttl.float> to tensor<2x2xf32>
// CHECK:               scf.yield %[[VAL_7]], %[[VAL_11]], %[[VAL_47]] : i32, f32, tensor<2x2xf32>
// CHECK:             }
// CHECK:             %[[VAL_48:.*]] = arith.constant 9.000000e+00 : f32
// CHECK:             scf.yield %[[VAL_48]], %[[VAL_12]], %[[VAL_49:.*]]#0, %[[VAL_49]]#2, %[[VAL_6]] : f32, i32, i32, tensor<2x2xf32>, i32
// CHECK:           } else {
// CHECK:             %[[VAL_50:.*]] = arith.constant 8.000000e+00 : f32
// CHECK:             %[[VAL_51:.*]] = arith.constant 8 : i32
// CHECK:             scf.yield %[[VAL_50]], %[[VAL_5]], %[[VAL_7]], %[[VAL_4]], %[[VAL_51]] : f32, i32, i32, tensor<2x2xf32>, i32
// CHECK:           }
// CHECK:           %[[VAL_52:.*]] = builtin.unrealized_conversion_cast %[[VAL_53:.*]]#3 : tensor<2x2xf32> to !ttl.tensor<2x2x!ttl.float>
// CHECK:           %[[VAL_54:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_55:.*]] = builtin.unrealized_conversion_cast %[[VAL_54]] : i32 to !ttl.int
// CHECK:           %[[VAL_56:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_57:.*]] = builtin.unrealized_conversion_cast %[[VAL_56]] : i32 to !ttl.int
// CHECK:           %[[VAL_58:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_59:.*]] = builtin.unrealized_conversion_cast %[[VAL_58]] : i32 to !ttl.int
// CHECK:           %[[VAL_60:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_61:.*]] = builtin.unrealized_conversion_cast %[[VAL_60]] : i32 to !ttl.int
// CHECK:           %[[VAL_62:.*]] = "ttl.slice"(%[[VAL_52]], %[[VAL_55]], %[[VAL_59]], %[[VAL_57]], %[[VAL_61]]) : (!ttl.tensor<2x2x!ttl.float>, !ttl.int, !ttl.int, !ttl.int, !ttl.int) -> !ttl.float
// CHECK:           %[[VAL_63:.*]] = builtin.unrealized_conversion_cast %[[VAL_62]] : !ttl.float to f32
// CHECK:           %[[VAL_64:.*]] = arith.addf %[[VAL_53]]#0, %[[VAL_63]] : f32
// CHECK:           return %[[VAL_64]] : f32
// CHECK:         }

