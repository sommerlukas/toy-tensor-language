// RUN: ttl-opt --convert-ttl-to-scalar %s | FileCheck %s

module {
  func.func @gt(%arg0: !ttl.float, %arg1: !ttl.float) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 0 : i32}> : (!ttl.float, !ttl.float) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @ge(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 2 : i32}> : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @lt(%arg0: !ttl.float, %arg1: !ttl.float) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 1 : i32}> : (!ttl.float, !ttl.float) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @le(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 3 : i32}> : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @eq(%arg0: !ttl.float, %arg1: !ttl.float) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 4 : i32}> : (!ttl.float, !ttl.float) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @ne(%arg0: !ttl.float, %arg1: !ttl.float) -> !ttl.int {
    %0 = "ttl.cmp"(%arg0, %arg1) <{opcode = 5 : i32}> : (!ttl.float, !ttl.float) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @gt(
// CHECK-SAME:                  %[[VAL_0:.*]]: f32,
// CHECK-SAME:                  %[[VAL_1:.*]]: f32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpf ugt, %[[VAL_0]], %[[VAL_1]] : f32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @ge(
// CHECK-SAME:                  %[[VAL_0:.*]]: i32,
// CHECK-SAME:                  %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpi sge, %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @lt(
// CHECK-SAME:                  %[[VAL_0:.*]]: f32,
// CHECK-SAME:                  %[[VAL_1:.*]]: f32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpf ult, %[[VAL_0]], %[[VAL_1]] : f32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @le(
// CHECK-SAME:                  %[[VAL_0:.*]]: i32,
// CHECK-SAME:                  %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpi sle, %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @eq(
// CHECK-SAME:                  %[[VAL_0:.*]]: f32,
// CHECK-SAME:                  %[[VAL_1:.*]]: f32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpf ueq, %[[VAL_0]], %[[VAL_1]] : f32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @ne(
// CHECK-SAME:                  %[[VAL_0:.*]]: f32,
// CHECK-SAME:                  %[[VAL_1:.*]]: f32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.cmpf une, %[[VAL_0]], %[[VAL_1]] : f32
// CHECK:           %[[VAL_3:.*]] = arith.extsi %[[VAL_2]] : i1 to i32
// CHECK:           return %[[VAL_3]] : i32
// CHECK:         }

