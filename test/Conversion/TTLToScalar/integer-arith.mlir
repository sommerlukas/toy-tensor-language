// RUN: ttl-opt --convert-ttl-to-scalar %s | FileCheck %s

module {
  func.func @add(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.add"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @sub(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.sub"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @mul(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.mul"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @div(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.div"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @and(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.and"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @or(%arg0: !ttl.int, %arg1: !ttl.int) -> !ttl.int {
    %0 = "ttl.or"(%arg0, %arg1) : (!ttl.int, !ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @minus(%arg0: !ttl.int) -> !ttl.int {
    %0 = "ttl.minus"(%arg0) : (!ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
  func.func @not(%arg0: !ttl.int) -> !ttl.int {
    %0 = "ttl.not"(%arg0) : (!ttl.int) -> !ttl.int
    "ttl.return"(%0) : (!ttl.int) -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   func.func @add(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32,
// CHECK-SAME:                   %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.addi %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @sub(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32,
// CHECK-SAME:                   %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.subi %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @mul(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32,
// CHECK-SAME:                   %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.muli %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @div(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32,
// CHECK-SAME:                   %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.divsi %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @and(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32,
// CHECK-SAME:                   %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.andi %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @or(
// CHECK-SAME:                  %[[VAL_0:.*]]: i32,
// CHECK-SAME:                  %[[VAL_1:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_2:.*]] = arith.ori %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @minus(
// CHECK-SAME:                     %[[VAL_0:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_1:.*]] = arith.constant -1 : i32
// CHECK:           %[[VAL_2:.*]] = arith.muli %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

// CHECK-LABEL:   func.func @not(
// CHECK-SAME:                   %[[VAL_0:.*]]: i32) -> i32 {
// CHECK:           %[[VAL_1:.*]] = arith.constant -1 : i32
// CHECK:           %[[VAL_2:.*]] = arith.xori %[[VAL_0]], %[[VAL_1]] : i32
// CHECK:           return %[[VAL_2]] : i32
// CHECK:         }

